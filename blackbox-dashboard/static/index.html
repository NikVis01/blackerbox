<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackbox - KV-Cache Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
        }

        h1 {
            color: white;
            margin: 0;
            font-size: 2.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .nodes-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 20px;
        }

        .node-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            cursor: pointer;
            min-height: 250px;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .node-card:hover { transform: translateY(-5px); }

        .node-header { margin-bottom: 15px; }
        .node-name { font-size: 1.5rem; font-weight: 600; color: #333; margin-bottom: 8px; }
        .node-status { font-size: 0.85rem; color: #666; }

        .tracking-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 8px;
        }
        .tracking-badge.tracking { background: #d3f9d8; color: #2b8a3e; }
        .tracking-badge.not-tracking { background: #ffe3e3; color: #c92a2a; }

        .node-content { display: flex; gap: 30px; flex: 1; }
        .node-stats { flex: 1; display: flex; flex-direction: column; justify-content: center; }

        .utilization-display { text-align: center; margin-bottom: 15px; }
        .utilization-value {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
        }
        .utilization-label { font-size: 0.9rem; color: #666; margin-top: 8px; }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            margin: 12px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .ratio-display {
            display: flex;
            justify-content: space-around;
            padding-top: 12px;
            border-top: 2px solid #f0f0f0;
        }
        .ratio-item { text-align: center; }
        .ratio-value { font-size: 1.5rem; font-weight: 600; color: #667eea; }
        .ratio-label { font-size: 0.75rem; color: #999; margin-top: 4px; }

        .node-chart-container { flex: 1; position: relative; }
        .chart-title { font-size: 0.85rem; color: #999; text-align: center; margin-bottom: 8px; }

        .add-node-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .add-node-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }
        .modal.active { display: block; }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            margin: 50px auto;
        }
        .modal-content.wide { max-width: 95%; }

        .modal-header {
            font-size: 1.8rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: #f0f0f0;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
        .close-btn:hover { background: #e0e0e0; }

        .form-group { margin-bottom: 20px; }
        .form-label { display: block; font-size: 0.9rem; font-weight: 500; color: #666; margin-bottom: 8px; }
        .form-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
        }
        .form-input:focus { outline: none; border-color: #667eea; }

        .form-actions { display: flex; gap: 15px; margin-top: 30px; }
        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-secondary { background: #f0f0f0; color: #666; }

        .node-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .node-controls-left { display: flex; gap: 10px; align-items: center; }
        .node-controls-right { display: flex; gap: 10px; }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        .btn-toggle { background: #51cf66; color: white; }
        .btn-toggle.disabled { background: #ff6b6b; }
        .btn-edit { background: #339af0; color: white; }
        .btn-delete { background: #ff6b6b; color: white; }

        .node-status-badge { padding: 6px 12px; border-radius: 6px; font-size: 0.85rem; font-weight: 500; }
        .node-status-badge.enabled { background: #d3f9d8; color: #2b8a3e; }
        .node-status-badge.disabled { background: #ffe3e3; color: #c92a2a; }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
        }
        .chart-box { background: #f8f9fa; border-radius: 15px; padding: 20px; transition: opacity 0.15s ease; }
        .chart-box h3 { font-size: 1.1rem; color: #333; margin-bottom: 15px; }
        .chart-container { position: relative; height: 300px; transition: opacity 0.15s ease; }

        .message { padding: 15px; border-radius: 10px; text-align: center; margin-bottom: 20px; color: white; }
        .error { background: #ff6b6b; }
        .success { background: #51cf66; }

        .no-data {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            padding: 60px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
        }

        .refresh-info { text-align: center; color: rgba(255,255,255,0.8); font-size: 0.9rem; margin-top: 20px; }

        .time-range-selector {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .time-range-btn {
            padding: 6px 14px;
            margin: 0 4px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
        }

        .time-range-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .time-range-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }

        .auto-refresh-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(102, 126, 234, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .refresh-dot {
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            animation: pulse 5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Chat Interface */
        .chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            background: white;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            max-height: 600px;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .chat-container.minimized {
            transform: translateY(calc(100% - 60px));
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .chat-header h3 {
            margin: 0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-toggle-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .chat-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
            min-height: 300px;
            max-height: 400px;
        }

        .chat-message {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .chat-message.user {
            align-items: flex-end;
        }

        .chat-message.assistant {
            align-items: flex-start;
        }

        .chat-bubble {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            word-wrap: break-word;
        }

        .chat-message.user .chat-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .chat-message.assistant .chat-bubble {
            background: white;
            color: #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chat-loading {
            display: flex;
            gap: 5px;
            padding: 10px;
        }

        .chat-loading span {
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .chat-loading span:nth-child(1) { animation-delay: -0.32s; }
        .chat-loading span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .chat-suggestions {
            padding: 10px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .suggestion-btn {
            padding: 6px 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .suggestion-btn:hover {
            border-color: #667eea;
            background: #f0f0ff;
        }

        .chat-input-container {
            padding: 15px 20px;
            background: white;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            font-size: 0.9rem;
            outline: none;
        }

        .chat-input:focus {
            border-color: #667eea;
        }

        .chat-send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
        }

        .chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .node-selector {
            padding: 10px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            max-height: 120px;
            overflow-y: auto;
        }

        .node-selector-label {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
            flex-shrink: 0;
        }

        .node-selection-count {
            font-size: 0.75rem;
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            padding: 4px 8px;
            border-radius: 10px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .node-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .node-checkbox.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .node-checkbox input {
            cursor: pointer;
        }

        .stats-summary {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stats-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.3rem;
            font-weight: 600;
            color: #667eea;
        }

        /* Node-specific chat in detail modal */
        .detail-chat {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .detail-chat-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detail-chat-body {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }

        .detail-chat-input-container {
            display: flex;
            gap: 10px;
        }

        .detail-chat-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="navbar">
            <h1>ðŸŽ¯ KV-Cache Monitor</h1>
            <button class="add-node-btn" onclick="openAddModal()">
                <span style="font-size: 1.5rem;">+</span>
                <span>Add Node</span>
            </button>
        </div>
        <div id="message-container"></div>
        <div id="nodes-container" class="nodes-grid"></div>
        <div class="refresh-info">Auto-refresh every 5 seconds</div>
    </div>

    <!-- Chat Interface -->
    <div class="chat-container" id="chatContainer">
        <div class="chat-header" onclick="toggleChat()">
            <h3>ðŸ’¬ AI Assistant</h3>
            <button class="chat-toggle-btn" id="chatToggleBtn">âˆ’</button>
        </div>

        <div class="node-selector" id="nodeSelector">
            <span class="node-selector-label">Analyze:</span>
            <label class="node-checkbox selected" id="allNodesCheckbox">
                <input type="checkbox" checked onchange="toggleAllNodes(this)"> All Nodes
            </label>
            <span class="node-selection-count" id="nodeSelectionCount" style="display: none;"></span>
            <div id="nodeSelectorList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
        </div>

        <div class="chat-suggestions" id="chatSuggestions">
            <button class="suggestion-btn" onclick="askQuestion('What does my KV-cache utilization tell me?')">
                KV-cache analysis
            </button>
            <button class="suggestion-btn" onclick="askQuestion('What are your recommendations?')">
                Get recommendations
            </button>
            <button class="suggestion-btn" onclick="askQuestion('Are there any performance issues?')">
                Performance check
            </button>
            <button class="suggestion-btn" onclick="askQuestion('Explain memory fragmentation')">
                Memory status
            </button>
        </div>

        <div class="chat-body" id="chatBody">
            <div class="chat-message assistant">
                <div class="chat-bubble">
                    Hi! I can analyze your GPU metrics and answer questions about KV-cache utilization, memory usage, and performance. Try one of the suggestions below or ask me anything!
                </div>
            </div>
        </div>

        <div class="chat-input-container">
            <input
                type="text"
                class="chat-input"
                id="chatInput"
                placeholder="Ask about your GPU metrics..."
                onkeypress="if(event.key==='Enter') sendMessage()"
            >
            <button class="chat-send-btn" id="chatSendBtn" onclick="sendMessage()">âž¤</button>
        </div>
    </div>

    <!-- Add Node Modal -->
    <div id="addNodeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Add New Node</span>
                <button class="close-btn" onclick="closeAddModal()">&times;</button>
            </div>
            <div id="add-message"></div>
            <form onsubmit="handleAddNode(event)">
                <div class="form-group">
                    <label class="form-label">Node Name</label>
                    <input type="text" id="nodeName" class="form-input" placeholder="e.g., gpu-server-1" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Host</label>
                    <input type="text" id="nodeHost" class="form-input" placeholder="e.g., 192.168.1.100" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Port</label>
                    <input type="number" id="nodePort" class="form-input" value="6767" required>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeAddModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add Node</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Detail Modal -->
    <div id="detailModal" class="modal">
        <div class="modal-content wide">
            <div class="modal-header">
                <span id="detailNodeName">Node Details</span>
                <button class="close-btn" onclick="closeDetailModal()">&times;</button>
            </div>
            <div id="detailContent"></div>
        </div>
    </div>

    <script>
        const API_BASE = '/api';
        const REFRESH_INTERVAL = 5000;  // 5 seconds

        let nodes = [];
        let charts = {};
        let detailCharts = {};
        let refreshTimer = null;
        let detailRefreshTimer = null;
        let currentNode = null;
        let currentTimeRange = 3600; // Default: 1 hour in seconds

        // === DATA FETCHING ===
        async function fetchNodes() {
            const res = await fetch(`${API_BASE}/nodes`);
            return res.ok ? await res.json() : [];
        }

        async function fetchSnapshot(nodeId) {
            const res = await fetch(`${API_BASE}/snapshots/latest?node_id=${nodeId}`);
            return res.ok ? await res.json() : null;
        }

        async function fetchTimeseries(nodeId, metric, duration = currentTimeRange) {
            const res = await fetch(`${API_BASE}/timeseries/${metric}?node_id=${nodeId}&duration=${duration}`);
            const data = res.ok ? await res.json() : [];
            console.log(`[fetchTimeseries] ${metric} for node ${nodeId} (${duration}s): ${data.length} points`);
            if (data.length > 0) {
                console.log('  First point:', data[0]);
                console.log('  Last point:', data[data.length - 1]);
                console.log('  Time range:', new Date(data[0].timestamp).toLocaleTimeString(), 'â†’', new Date(data[data.length - 1].timestamp).toLocaleTimeString());
            }
            return data;
        }

        async function fetchNodeStats(nodeId, duration = currentTimeRange) {
            try {
                const [kvData, memData, fragData] = await Promise.all([
                    fetchTimeseries(nodeId, 'kv_cache_utilization', duration),
                    fetchTimeseries(nodeId, 'vllm_memory_utilization', duration),
                    fetchTimeseries(nodeId, 'memory_fragmentation', duration)
                ]);

                if (kvData.length === 0) return null;

                const kvValues = kvData.map(d => d.value);
                const memValues = memData.map(d => d.value);
                const fragValues = fragData.map(d => d.value);

                return {
                    kv_avg: kvValues.reduce((a, b) => a + b, 0) / kvValues.length,
                    kv_max: Math.max(...kvValues),
                    kv_min: Math.min(...kvValues),
                    mem_avg: memValues.reduce((a, b) => a + b, 0) / memValues.length,
                    mem_max: Math.max(...memValues),
                    mem_min: Math.min(...memValues),
                    frag_avg: fragValues.reduce((a, b) => a + b, 0) / fragValues.length,
                    frag_max: Math.max(...fragValues),
                    count: kvData.length
                };
            } catch (error) {
                console.error('Error fetching stats:', error);
                return null;
            }
        }

        // === UTILITIES ===
        function showMessage(msg, type = 'error') {
            const container = document.getElementById('message-container');
            container.innerHTML = `<div class="message ${type}">${msg}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function formatTime(timestamp) {
            const diff = Math.floor((Date.now() - new Date(timestamp)) / 1000);
            if (diff < 60) return `${diff}s ago`;
            if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
            return new Date(timestamp).toLocaleTimeString();
        }

        function getTimeRangeLabel(duration) {
            if (duration === 300) return '5 minutes';
            if (duration === 3600) return '1 hour';
            if (duration === 10800) return '3 hours';
            if (duration === 21600) return '6 hours';
            if (duration === 43200) return '12 hours';
            if (duration === 86400) return '24 hours';
            if (duration === 604800) return '7 days';
            return `${duration}s`;
        }

        function calcUtilization(snapshot) {
            if (!snapshot) return { util: 0, utilized: 0, allocated: 0 };
            return {
                util: snapshot.kv_cache_utilization || 0,
                utilized: snapshot.utilized_blocks || 0,
                allocated: snapshot.allocated_blocks || 0
            };
        }

        // === CHART CREATION ===
        function createOrUpdateChart(canvasId, data, color = '#667eea') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            console.log(`[createOrUpdateChart] ${canvasId}: rendering ${data.length} points`);

            const now = new Date();
            const oneHourAgo = new Date(now - 3600 * 1000);

            if (charts[canvasId]) {
                charts[canvasId].data.labels = data.map(d => new Date(d.timestamp));
                charts[canvasId].data.datasets[0].data = data.map(d => d.value);
                // Update time axis to show current hour window
                charts[canvasId].options.scales.x.min = oneHourAgo;
                charts[canvasId].options.scales.x.max = now;
                charts[canvasId].update('none');
                console.log(`[createOrUpdateChart] ${canvasId}: updated with ${data.length} points`);
                return;
            }

            console.log(`[createOrUpdateChart] ${canvasId}: creating new chart with ${data.length} points`);

            charts[canvasId] = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: data.map(d => new Date(d.timestamp)),
                    datasets: [{
                        data: data.map(d => d.value),
                        borderColor: color,
                        backgroundColor: color + '33',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: ctx => `${ctx.parsed.y.toFixed(1)}%`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: oneHourAgo,
                            max: now,
                            time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                            grid: { color: 'rgba(0,0,0,0.05)' },
                            ticks: { color: '#666', font: { size: 11 } }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: 'rgba(0,0,0,0.05)' },
                            ticks: {
                                color: '#666',
                                font: { size: 11 },
                                callback: v => v + '%'
                            }
                        }
                    }
                }
            });
        }

        // === NODE CARD RENDERING ===
        function createNodeCardHTML(node) {
            return `
                <div class="node-card" onclick="openDetail(${node.id}, '${node.name}')" data-node-id="${node.id}">
                    <div class="node-header">
                        <div class="node-name">
                            <span data-name>${node.name}</span>
                            <span data-badge class="tracking-badge not-tracking">Loading...</span>
                        </div>
                        <div class="node-status" data-status>
                            ðŸ”´ Offline â€¢ ${node.host}:${node.port}
                        </div>
                    </div>
                    <div class="node-content">
                        <div class="node-stats">
                            <div class="utilization-display">
                                <div class="utilization-value" data-util>0.0%</div>
                                <div class="utilization-label">KV-Cache Utilization</div>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" data-progress style="width: 0%"></div>
                            </div>
                            <div class="ratio-display">
                                <div class="ratio-item">
                                    <div class="ratio-value" data-utilized>0</div>
                                    <div class="ratio-label">Utilized Blocks</div>
                                </div>
                                <div class="ratio-item">
                                    <div class="ratio-value" data-active>0</div>
                                    <div class="ratio-label">Allocated Blocks</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateNodeCard(card, node, snapshot) {
            const { util, utilized, allocated } = calcUtilization(snapshot);

            // Update tracking badge
            const badge = card.querySelector('[data-badge]');
            if (node.enabled) {
                if (snapshot) {
                    badge.textContent = 'Tracking';
                    badge.className = 'tracking-badge tracking';
                } else {
                    badge.textContent = 'Waiting...';
                    badge.className = 'tracking-badge not-tracking';
                }
            } else {
                badge.textContent = 'Disabled';
                badge.className = 'tracking-badge not-tracking';
            }

            // Update status
            const status = card.querySelector('[data-status]');
            const isOnline = snapshot && node.enabled;
            status.innerHTML = `
                ${isOnline ? 'ðŸŸ¢ Online' : 'ðŸ”´ Offline'} â€¢ ${node.host}:${node.port}
                ${snapshot ? ` â€¢ ${formatTime(snapshot.timestamp)}` : ''}
            `;

            // Update metrics
            card.querySelector('[data-util]').textContent = `${util.toFixed(1)}%`;
            card.querySelector('[data-progress]').style.width = `${util}%`;
            card.querySelector('[data-utilized]').textContent = utilized;
            card.querySelector('[data-active]').textContent = allocated;
        }

        // === UPDATE FUNCTIONS ===
        async function updateDashboard() {
            nodes = await fetchNodes();
            const container = document.getElementById('nodes-container');

            if (nodes.length === 0) {
                container.innerHTML = '<div class="no-data">No nodes configured. Click + to add a node.</div>';
                return;
            }

            const existingNodeIds = new Set(
                Array.from(container.querySelectorAll('[data-node-id]')).map(el => parseInt(el.dataset.nodeId))
            );
            const currentNodeIds = new Set(nodes.map(n => n.id));

            // Check if we need to rebuild (nodes added/removed)
            const needsRebuild = existingNodeIds.size !== currentNodeIds.size ||
                                 ![...currentNodeIds].every(id => existingNodeIds.has(id));

            if (needsRebuild) {
                // Complete rebuild
                container.innerHTML = nodes.map(n => createNodeCardHTML(n)).join('');

                // Update all cards
                for (const node of nodes) {
                    const card = container.querySelector(`[data-node-id="${node.id}"]`);
                    const snapshot = await fetchSnapshot(node.id);
                    updateNodeCard(card, node, snapshot);
                }
            } else {
                // Just update existing cards
                for (const node of nodes) {
                    const card = container.querySelector(`[data-node-id="${node.id}"]`);
                    if (!card) continue;

                    const snapshot = await fetchSnapshot(node.id);
                    updateNodeCard(card, node, snapshot);
                }
            }
        }

        // === NODE DETAIL ===
        async function openDetail(nodeId, nodeName) {
            console.log(`[openDetail] Opening detail for node ${nodeId} (${nodeName})`);

            const res = await fetch(`${API_BASE}/nodes/${nodeId}`);
            if (!res.ok) return showMessage('Failed to load node details');

            currentNode = await res.json();
            document.getElementById('detailNodeName').textContent = `${nodeName} - Details`;
            document.getElementById('detailModal').classList.add('active');

            const metrics = [
                { key: 'kv_cache_utilization', title: 'KV-Cache Utilization (%)', color: '#667eea' },
                { key: 'vllm_memory_utilization', title: 'vLLM Memory Utilization (%)', color: '#764ba2' },
                { key: 'allocated_blocks', title: 'Allocated Blocks (Total)', color: '#51cf66' },
                { key: 'utilized_blocks', title: 'Utilized Blocks (In Use)', color: '#228be6' },
                { key: 'memory_fragmentation', title: 'Memory Fragmentation', color: '#ff6b6b' },
                { key: 'used_bytes', title: 'Used Memory (Bytes)', color: '#ffd43b' },
                { key: 'num_processes', title: 'Number of Processes', color: '#339af0' }
            ];

            // Fetch stats for average calculation
            const statsData = await fetchNodeStats(nodeId, currentTimeRange);

            const controls = `
                <div style="position: relative;">
                    <div class="auto-refresh-indicator">
                        <div class="refresh-dot"></div>
                        <span>Auto-refresh: 5s</span>
                    </div>
                    <div class="node-controls">
                        <div class="node-controls-left">
                            <span class="node-status-badge ${currentNode.enabled ? 'enabled' : 'disabled'}">
                                ${currentNode.enabled ? 'Enabled' : 'Disabled'}
                            </span>
                            <span style="color: #666;">${currentNode.host}:${currentNode.port}</span>
                        </div>
                        <div class="node-controls-right">
                            <button class="btn-small btn-toggle ${!currentNode.enabled ? 'disabled' : ''}" onclick="toggleNode()">
                                ${currentNode.enabled ? 'Disable' : 'Enable'} Tracking
                            </button>
                            <button class="btn-small btn-edit" onclick="editNode()">Edit</button>
                            <button class="btn-small btn-delete" onclick="deleteNode()">Delete</button>
                        </div>
                    </div>
                    <div class="time-range-selector">
                        <span style="color: #666; margin-right: 10px; font-weight: 500;">Time Range:</span>
                        <button class="time-range-btn ${currentTimeRange === 300 ? 'active' : ''}" onclick="changeTimeRange(300)">5m</button>
                        <button class="time-range-btn ${currentTimeRange === 3600 ? 'active' : ''}" onclick="changeTimeRange(3600)">1h</button>
                        <button class="time-range-btn ${currentTimeRange === 10800 ? 'active' : ''}" onclick="changeTimeRange(10800)">3h</button>
                        <button class="time-range-btn ${currentTimeRange === 21600 ? 'active' : ''}" onclick="changeTimeRange(21600)">6h</button>
                        <button class="time-range-btn ${currentTimeRange === 43200 ? 'active' : ''}" onclick="changeTimeRange(43200)">12h</button>
                        <button class="time-range-btn ${currentTimeRange === 86400 ? 'active' : ''}" onclick="changeTimeRange(86400)">24h</button>
                        <button class="time-range-btn ${currentTimeRange === 604800 ? 'active' : ''}" onclick="changeTimeRange(604800)">7d</button>
                    </div>
                    ${statsData ? `
                    <div class="stats-summary">
                        <div class="stats-header">ðŸ“Š Period Statistics (${getTimeRangeLabel(currentTimeRange)})</div>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Avg KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Memory:</span>
                                <span class="stat-value">${statsData.mem_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max Memory:</span>
                                <span class="stat-value">${statsData.mem_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Fragmentation:</span>
                                <span class="stat-value">${(statsData.frag_avg * 100).toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Data Points:</span>
                                <span class="stat-value">${statsData.count}</span>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;

            const chartsHtml = metrics.map(m => `
                <div class="chart-box">
                    <h3>${m.title}</h3>
                    <div class="chart-container">
                        <canvas id="detail-${m.key}"></canvas>
                    </div>
                </div>
            `).join('');

            const chatHtml = `
                <div class="detail-chat">
                    <div class="detail-chat-header">ðŸ’¬ Ask AI about this node</div>
                    <div class="detail-chat-suggestions">
                        <button class="suggestion-btn" onclick="askDetailQuestion('Analyze this node performance')">
                            Performance Analysis
                        </button>
                        <button class="suggestion-btn" onclick="askDetailQuestion('What optimizations do you recommend?')">
                            Optimization Tips
                        </button>
                        <button class="suggestion-btn" onclick="askDetailQuestion('Explain the current metrics')">
                            Explain Metrics
                        </button>
                    </div>
                    <div class="detail-chat-body" id="detailChatBody">
                        <div class="chat-message assistant">
                            <div class="chat-bubble">
                                Ask me anything about ${nodeName}'s performance, KV-cache utilization, or get recommendations!
                            </div>
                        </div>
                    </div>
                    <div class="detail-chat-input-container">
                        <input
                            type="text"
                            class="chat-input"
                            id="detailChatInput"
                            placeholder="Ask about this node..."
                            onkeypress="if(event.key==='Enter') sendDetailMessage()"
                        >
                        <button class="chat-send-btn" id="detailChatSendBtn" onclick="sendDetailMessage()">âž¤</button>
                    </div>
                </div>
            `;

            document.getElementById('detailContent').innerHTML = controls + '<div class="charts-grid">' + chartsHtml + '</div>' + chatHtml;

            console.log(`[openDetail] Fetching timeseries for ${metrics.length} metrics...`);

            for (const m of metrics) {
                const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                console.log(`[openDetail] Got ${data.length} points for ${m.key}, creating chart...`);
                createDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
            }

            console.log(`[openDetail] All charts created`);

            // Start auto-refresh for detail charts
            startDetailRefresh(nodeId, metrics);
        }

        function startDetailRefresh(nodeId, metrics) {
            // Clear any existing timer
            if (detailRefreshTimer) {
                clearInterval(detailRefreshTimer);
            }

            // Refresh charts and stats every 5 seconds
            detailRefreshTimer = setInterval(async () => {
                console.log(`[detailRefresh] Updating charts and stats for node ${nodeId}`);

                // Update stats summary
                const statsData = await fetchNodeStats(nodeId, currentTimeRange);
                if (statsData) {
                    const statsContainer = document.querySelector('.stats-summary');
                    if (statsContainer) {
                        statsContainer.innerHTML = `
                            <div class="stats-header">ðŸ“Š Period Statistics (${getTimeRangeLabel(currentTimeRange)})</div>
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-label">Avg KV-Cache:</span>
                                    <span class="stat-value">${statsData.kv_avg.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Max KV-Cache:</span>
                                    <span class="stat-value">${statsData.kv_max.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Avg Memory:</span>
                                    <span class="stat-value">${statsData.mem_avg.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Max Memory:</span>
                                    <span class="stat-value">${statsData.mem_max.toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Avg Fragmentation:</span>
                                    <span class="stat-value">${(statsData.frag_avg * 100).toFixed(2)}%</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Data Points:</span>
                                    <span class="stat-value">${statsData.count}</span>
                                </div>
                            </div>
                        `;
                    }
                }

                // Update charts
                for (const m of metrics) {
                    const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                    updateDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
                }
            }, REFRESH_INTERVAL);
        }

        async function changeTimeRange(duration) {
            if (!currentNode) return;

            currentTimeRange = duration;
            console.log(`[changeTimeRange] Changed to ${duration}s (${duration/3600}h)`);

            // Re-fetch data and update all charts
            const nodeId = currentNode.id;
            const metrics = [
                { key: 'kv_cache_utilization', title: 'KV-Cache Utilization (%)', color: '#667eea' },
                { key: 'vllm_memory_utilization', title: 'vLLM Memory Utilization (%)', color: '#764ba2' },
                { key: 'allocated_blocks', title: 'Allocated Blocks (Total)', color: '#51cf66' },
                { key: 'utilized_blocks', title: 'Utilized Blocks (In Use)', color: '#228be6' },
                { key: 'memory_fragmentation', title: 'Memory Fragmentation', color: '#ff6b6b' },
                { key: 'used_bytes', title: 'Used Memory (Bytes)', color: '#ffd43b' },
                { key: 'num_processes', title: 'Number of Processes', color: '#339af0' }
            ];

            // Update button states
            document.querySelectorAll('.time-range-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Reload stats summary with new time range
            const statsData = await fetchNodeStats(nodeId, currentTimeRange);
            if (statsData) {
                const statsContainer = document.querySelector('.stats-summary');
                if (statsContainer) {
                    statsContainer.innerHTML = `
                        <div class="stats-header">ðŸ“Š Period Statistics (${getTimeRangeLabel(currentTimeRange)})</div>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Avg KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max KV-Cache:</span>
                                <span class="stat-value">${statsData.kv_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Memory:</span>
                                <span class="stat-value">${statsData.mem_avg.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Max Memory:</span>
                                <span class="stat-value">${statsData.mem_max.toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Avg Fragmentation:</span>
                                <span class="stat-value">${(statsData.frag_avg * 100).toFixed(2)}%</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Data Points:</span>
                                <span class="stat-value">${statsData.count}</span>
                            </div>
                        </div>
                    `;
                }
            }

            // Reload all charts with new time range
            for (const m of metrics) {
                const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                createDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
            }

            // Restart auto-refresh with new time range
            startDetailRefresh(nodeId, metrics);
        }

        function createDetailChart(canvasId, data, color, duration = currentTimeRange) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.warn(`[createDetailChart] Canvas not found: ${canvasId}`);
                return;
            }

            if (detailCharts[canvasId]) {
                detailCharts[canvasId].destroy();
            }

            console.log(`[createDetailChart] ${canvasId}: Creating chart with ${data.length} points for ${duration}s range`);

            const now = new Date();
            const startTime = new Date(now - duration * 1000);

            // Determine appropriate time unit based on duration
            let timeUnit = 'minute';
            let displayFormat = 'HH:mm';

            if (duration > 86400) { // > 1 day
                timeUnit = 'day';
                displayFormat = 'MMM dd';
            } else if (duration > 7200) { // > 2 hours
                timeUnit = 'hour';
                displayFormat = 'HH:mm';
            } else if (duration <= 600) { // <= 10 minutes
                timeUnit = 'minute';
                displayFormat = 'HH:mm:ss';
            }

            const chartData = {
                labels: data.map(d => new Date(d.timestamp)),
                datasets: [{
                    data: data.map(d => d.value),
                    borderColor: color,
                    backgroundColor: color + '33',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: data.length > 100 ? 0 : 2  // Hide points if too many
                }]
            };

            console.log(`[createDetailChart] ${canvasId}: Chart has ${chartData.labels.length} labels and ${chartData.datasets[0].data.length} data points`);

            detailCharts[canvasId] = new Chart(canvas, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: startTime,
                            max: now,
                            time: {
                                unit: timeUnit,
                                displayFormats: {
                                    second: 'HH:mm:ss',
                                    minute: displayFormat,
                                    hour: 'HH:mm',
                                    day: 'MMM dd'
                                }
                            }
                        },
                        y: { beginAtZero: true }
                    }
                }
            });
        }

        function updateDetailChart(canvasId, data, color, duration = currentTimeRange) {
            const chart = detailCharts[canvasId];
            if (!chart) {
                console.warn(`[updateDetailChart] Chart not found: ${canvasId}, creating new one`);
                createDetailChart(canvasId, data, color, duration);
                return;
            }

            const now = new Date();
            const startTime = new Date(now - duration * 1000);

            // Update data
            chart.data.labels = data.map(d => new Date(d.timestamp));
            chart.data.datasets[0].data = data.map(d => d.value);
            chart.data.datasets[0].pointRadius = data.length > 100 ? 0 : 2;

            // Update time axis
            chart.options.scales.x.min = startTime;
            chart.options.scales.x.max = now;

            // Update chart without animation for smoother updates
            chart.update('none');

            // Brief visual feedback on update
            const canvas = chart.canvas;
            if (canvas && canvas.parentElement) {
                canvas.parentElement.style.opacity = '0.7';
                setTimeout(() => {
                    canvas.parentElement.style.opacity = '1';
                }, 100);
            }
        }

        function closeDetailModal() {
            document.getElementById('detailModal').classList.remove('active');

            // Stop auto-refresh
            if (detailRefreshTimer) {
                clearInterval(detailRefreshTimer);
                detailRefreshTimer = null;
            }

            Object.values(detailCharts).forEach(c => c.destroy());
            detailCharts = {};
            currentNode = null;
            currentTimeRange = 3600; // Reset to default 1 hour
        }

        // === NODE ACTIONS ===
        async function toggleNode() {
            if (!currentNode) return;
            const newState = !currentNode.enabled;
            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}?enabled=${newState}`, { method: 'PUT' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage(`Node ${newState ? 'enabled' : 'disabled'} successfully`, 'success');
            } else {
                showMessage('Failed to toggle node');
            }
        }

        async function editNode() {
            if (!currentNode) return;
            const name = prompt('Node Name:', currentNode.name);
            if (!name) return;
            const host = prompt('Host:', currentNode.host);
            if (!host) return;
            const port = prompt('Port:', currentNode.port);
            if (!port) return;

            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}?name=${encodeURIComponent(name)}&host=${encodeURIComponent(host)}&port=${port}`, { method: 'PUT' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage('Node updated successfully', 'success');
            } else {
                showMessage('Failed to update node');
            }
        }

        async function deleteNode() {
            if (!currentNode) return;
            if (!confirm(`Delete "${currentNode.name}"?\n\nThis will delete all data and cannot be undone.`)) return;

            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}`, { method: 'DELETE' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage('Node deleted successfully', 'success');
            } else {
                showMessage('Failed to delete node');
            }
        }

        // === ADD NODE ===
        function openAddModal() {
            document.getElementById('addNodeModal').classList.add('active');
            document.getElementById('nodeName').value = '';
            document.getElementById('nodeHost').value = '';
            document.getElementById('nodePort').value = '6767';
            document.getElementById('add-message').innerHTML = '';
        }

        function closeAddModal() {
            document.getElementById('addNodeModal').classList.remove('active');
        }

        async function handleAddNode(e) {
            e.preventDefault();
            const name = document.getElementById('nodeName').value.trim();
            const host = document.getElementById('nodeHost').value.trim();
            const port = parseInt(document.getElementById('nodePort').value);

            const res = await fetch(`${API_BASE}/nodes`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, host, port })
            });

            if (res.ok) {
                document.getElementById('add-message').innerHTML = `<div class="message success">Node "${name}" added!</div>`;
                setTimeout(() => {
                    closeAddModal();
                    updateDashboard();
                }, 1500);
            } else {
                const err = await res.json();
                document.getElementById('add-message').innerHTML = `<div class="message error">${err.detail || 'Failed to add node'}</div>`;
            }
        }

        // === CHAT INTERFACE ===
        let selectedNodeIds = [];  // Empty means all nodes
        let chatMinimized = false;

        function toggleChat() {
            const container = document.getElementById('chatContainer');
            const btn = document.getElementById('chatToggleBtn');
            chatMinimized = !chatMinimized;

            if (chatMinimized) {
                container.classList.add('minimized');
                btn.textContent = '+';
            } else {
                container.classList.remove('minimized');
                btn.textContent = 'âˆ’';
            }
        }

        function updateNodeSelector() {
            const list = document.getElementById('nodeSelectorList');
            if (!nodes || nodes.length === 0) {
                list.innerHTML = '';
                return;
            }

            // Only update if the node list has changed
            const currentNodeIds = nodes.map(n => n.id).sort().join(',');
            const existingNodeIds = Array.from(list.querySelectorAll('input[type="checkbox"]'))
                .map(input => input.value)
                .sort()
                .join(',');

            if (currentNodeIds === existingNodeIds) {
                return; // No changes needed
            }

            // Rebuild node list
            list.innerHTML = nodes.map(node => {
                const isSelected = selectedNodeIds.includes(node.id);
                return `
                    <label class="node-checkbox ${isSelected ? 'selected' : ''}" id="node-check-${node.id}">
                        <input type="checkbox" value="${node.id}" ${isSelected ? 'checked' : ''} onchange="toggleNodeSelection(${node.id}, this)">
                        ${node.name}
                    </label>
                `;
            }).join('');
        }

        function updateSelectionCount() {
            const countEl = document.getElementById('nodeSelectionCount');
            if (selectedNodeIds.length === 0) {
                countEl.style.display = 'none';
            } else {
                const totalEnabled = nodes.filter(n => n.enabled).length;
                countEl.textContent = `${selectedNodeIds.length} of ${totalEnabled} nodes`;
                countEl.style.display = 'block';
            }
        }

        function toggleAllNodes(checkbox) {
            const allCheckbox = document.getElementById('allNodesCheckbox');
            const nodeCheckboxes = document.querySelectorAll('#nodeSelectorList input[type="checkbox"]');

            if (checkbox.checked) {
                // "All Nodes" selected - clear individual selections
                allCheckbox.classList.add('selected');
                selectedNodeIds = [];
                nodeCheckboxes.forEach(cb => {
                    cb.checked = false;
                    cb.parentElement.classList.remove('selected');
                });
                updateSelectionCount();
                console.log('[Node Selector] All nodes selected');
            } else {
                // User unchecked "All Nodes" - they must select at least one individual node
                // Don't allow unchecking if no nodes are selected
                if (selectedNodeIds.length === 0) {
                    checkbox.checked = true;
                    allCheckbox.classList.add('selected');
                    console.log('[Node Selector] Cannot uncheck "All Nodes" without selecting individual nodes');
                } else {
                    allCheckbox.classList.remove('selected');
                    updateSelectionCount();
                }
            }
        }

        function toggleNodeSelection(nodeId, checkbox) {
            const allCheckbox = document.getElementById('allNodesCheckbox');
            const allCheckboxInput = allCheckbox.querySelector('input');
            const nodeCheckbox = document.getElementById(`node-check-${nodeId}`);

            if (checkbox.checked) {
                // Add node to selection
                if (!selectedNodeIds.includes(nodeId)) {
                    selectedNodeIds.push(nodeId);
                }
                nodeCheckbox.classList.add('selected');

                // Uncheck "All Nodes"
                allCheckboxInput.checked = false;
                allCheckbox.classList.remove('selected');

                updateSelectionCount();
                console.log(`[Node Selector] Selected nodes: ${selectedNodeIds.join(', ')}`);
            } else {
                // Remove node from selection
                selectedNodeIds = selectedNodeIds.filter(id => id !== nodeId);
                nodeCheckbox.classList.remove('selected');

                // If no nodes selected, revert to "All Nodes"
                if (selectedNodeIds.length === 0) {
                    allCheckboxInput.checked = true;
                    allCheckbox.classList.add('selected');
                    console.log('[Node Selector] No nodes selected, reverting to All Nodes');
                } else {
                    console.log(`[Node Selector] Selected nodes: ${selectedNodeIds.join(', ')}`);
                }

                updateSelectionCount();
            }
        }

        function addChatMessage(message, isUser = false) {
            const chatBody = document.getElementById('chatBody');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isUser ? 'user' : 'assistant'}`;

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.textContent = message;

            messageDiv.appendChild(bubble);
            chatBody.appendChild(messageDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function showChatLoading() {
            const chatBody = document.getElementById('chatBody');
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant';
            loadingDiv.id = 'chat-loading';
            loadingDiv.innerHTML = `
                <div class="chat-loading">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatBody.appendChild(loadingDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function removeChatLoading() {
            const loading = document.getElementById('chat-loading');
            if (loading) loading.remove();
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('chatSendBtn');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addChatMessage(message, true);
            input.value = '';

            // Disable input while processing
            input.disabled = true;
            sendBtn.disabled = true;
            showChatLoading();

            try {
                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        node_ids: selectedNodeIds.length > 0 ? selectedNodeIds : null
                    })
                });

                removeChatLoading();

                if (response.ok) {
                    const data = await response.json();
                    addChatMessage(data.response, false);
                } else {
                    const error = await response.json();
                    addChatMessage(`Error: ${error.detail || 'Failed to get response'}`, false);
                }
            } catch (error) {
                removeChatLoading();
                addChatMessage(`Error: ${error.message}. Make sure Claude API key is set in .env file.`, false);
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function askQuestion(question) {
            const input = document.getElementById('chatInput');
            input.value = question;
            sendMessage();
        }

        // Detail modal chat functions
        function addDetailChatMessage(message, isUser = false) {
            const chatBody = document.getElementById('detailChatBody');
            if (!chatBody) return;

            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isUser ? 'user' : 'assistant'}`;

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.textContent = message;

            messageDiv.appendChild(bubble);
            chatBody.appendChild(messageDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function showDetailChatLoading() {
            const chatBody = document.getElementById('detailChatBody');
            if (!chatBody) return;

            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'chat-message assistant';
            loadingDiv.id = 'detail-chat-loading';
            loadingDiv.innerHTML = `
                <div class="chat-loading">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatBody.appendChild(loadingDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }

        function removeDetailChatLoading() {
            const loading = document.getElementById('detail-chat-loading');
            if (loading) loading.remove();
        }

        async function sendDetailMessage() {
            if (!currentNode) return;

            const input = document.getElementById('detailChatInput');
            const sendBtn = document.getElementById('detailChatSendBtn');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addDetailChatMessage(message, true);
            input.value = '';

            // Disable input while processing
            input.disabled = true;
            sendBtn.disabled = true;
            showDetailChatLoading();

            try {
                const response = await fetch(`${API_BASE}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        node_ids: [currentNode.id]
                    })
                });

                removeDetailChatLoading();

                if (response.ok) {
                    const data = await response.json();
                    addDetailChatMessage(data.response, false);
                } else {
                    const error = await response.json();
                    addDetailChatMessage(`Error: ${error.detail || 'Failed to get response'}`, false);
                }
            } catch (error) {
                removeDetailChatLoading();
                addDetailChatMessage(`Error: ${error.message}. Make sure Claude API key is set in .env file.`, false);
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function askDetailQuestion(question) {
            const input = document.getElementById('detailChatInput');
            if (input) {
                input.value = question;
                sendDetailMessage();
            }
        }

        // === INIT ===
        updateDashboard();
        refreshTimer = setInterval(updateDashboard, REFRESH_INTERVAL);

        // Update node selector periodically
        setInterval(updateNodeSelector, REFRESH_INTERVAL);

        document.getElementById('addNodeModal').addEventListener('click', e => {
            if (e.target.id === 'addNodeModal') closeAddModal();
        });
        document.getElementById('detailModal').addEventListener('click', e => {
            if (e.target.id === 'detailModal') closeDetailModal();
        });
    </script>
</body>
</html>
