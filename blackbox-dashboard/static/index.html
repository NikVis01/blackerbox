<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackbox - KV-Cache Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .nodes-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 20px;
        }

        .node-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            cursor: pointer;
            min-height: 250px;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .node-card:hover { transform: translateY(-5px); }

        .node-header { margin-bottom: 15px; }
        .node-name { font-size: 1.5rem; font-weight: 600; color: #333; margin-bottom: 8px; }
        .node-status { font-size: 0.85rem; color: #666; }

        .tracking-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 8px;
        }
        .tracking-badge.tracking { background: #d3f9d8; color: #2b8a3e; }
        .tracking-badge.not-tracking { background: #ffe3e3; color: #c92a2a; }

        .node-content { display: flex; gap: 30px; flex: 1; }
        .node-stats { flex: 1; display: flex; flex-direction: column; justify-content: center; }

        .utilization-display { text-align: center; margin-bottom: 15px; }
        .utilization-value {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1;
        }
        .utilization-label { font-size: 0.9rem; color: #666; margin-top: 8px; }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            margin: 12px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .ratio-display {
            display: flex;
            justify-content: space-around;
            padding-top: 12px;
            border-top: 2px solid #f0f0f0;
        }
        .ratio-item { text-align: center; }
        .ratio-value { font-size: 1.5rem; font-weight: 600; color: #667eea; }
        .ratio-label { font-size: 0.75rem; color: #999; margin-top: 4px; }

        .node-chart-container { flex: 1; position: relative; }
        .chart-title { font-size: 0.85rem; color: #999; text-align: center; margin-bottom: 8px; }

        .add-node-btn {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 2rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            z-index: 100;
        }
        .add-node-btn:hover { transform: scale(1.1); }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }
        .modal.active { display: block; }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            margin: 50px auto;
        }
        .modal-content.wide { max-width: 95%; }

        .modal-header {
            font-size: 1.8rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: #f0f0f0;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
        .close-btn:hover { background: #e0e0e0; }

        .form-group { margin-bottom: 20px; }
        .form-label { display: block; font-size: 0.9rem; font-weight: 500; color: #666; margin-bottom: 8px; }
        .form-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
        }
        .form-input:focus { outline: none; border-color: #667eea; }

        .form-actions { display: flex; gap: 15px; margin-top: 30px; }
        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-secondary { background: #f0f0f0; color: #666; }

        .node-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .node-controls-left { display: flex; gap: 10px; align-items: center; }
        .node-controls-right { display: flex; gap: 10px; }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        .btn-toggle { background: #51cf66; color: white; }
        .btn-toggle.disabled { background: #ff6b6b; }
        .btn-edit { background: #339af0; color: white; }
        .btn-delete { background: #ff6b6b; color: white; }

        .node-status-badge { padding: 6px 12px; border-radius: 6px; font-size: 0.85rem; font-weight: 500; }
        .node-status-badge.enabled { background: #d3f9d8; color: #2b8a3e; }
        .node-status-badge.disabled { background: #ffe3e3; color: #c92a2a; }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
        }
        .chart-box { background: #f8f9fa; border-radius: 15px; padding: 20px; transition: opacity 0.15s ease; }
        .chart-box h3 { font-size: 1.1rem; color: #333; margin-bottom: 15px; }
        .chart-container { position: relative; height: 300px; transition: opacity 0.15s ease; }

        .message { padding: 15px; border-radius: 10px; text-align: center; margin-bottom: 20px; color: white; }
        .error { background: #ff6b6b; }
        .success { background: #51cf66; }

        .no-data {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            padding: 60px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
        }

        .refresh-info { text-align: center; color: rgba(255,255,255,0.8); font-size: 0.9rem; margin-top: 20px; }

        .time-range-selector {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .time-range-btn {
            padding: 6px 14px;
            margin: 0 4px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #666;
        }

        .time-range-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .time-range-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }

        .auto-refresh-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(102, 126, 234, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .refresh-dot {
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¯ KV-Cache Monitor</h1>
        <div id="message-container"></div>
        <div id="nodes-container" class="nodes-grid"></div>
        <div class="refresh-info">Auto-refresh every 2 seconds</div>
    </div>

    <button class="add-node-btn" onclick="openAddModal()">+</button>

    <!-- Add Node Modal -->
    <div id="addNodeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>Add New Node</span>
                <button class="close-btn" onclick="closeAddModal()">&times;</button>
            </div>
            <div id="add-message"></div>
            <form onsubmit="handleAddNode(event)">
                <div class="form-group">
                    <label class="form-label">Node Name</label>
                    <input type="text" id="nodeName" class="form-input" placeholder="e.g., gpu-server-1" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Host</label>
                    <input type="text" id="nodeHost" class="form-input" placeholder="e.g., 192.168.1.100" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Port</label>
                    <input type="number" id="nodePort" class="form-input" value="6767" required>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeAddModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Add Node</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Detail Modal -->
    <div id="detailModal" class="modal">
        <div class="modal-content wide">
            <div class="modal-header">
                <span id="detailNodeName">Node Details</span>
                <button class="close-btn" onclick="closeDetailModal()">&times;</button>
            </div>
            <div id="detailContent"></div>
        </div>
    </div>

    <script>
        const API_BASE = '/api';
        const REFRESH_INTERVAL = 2000;  // 2 seconds

        let nodes = [];
        let charts = {};
        let detailCharts = {};
        let refreshTimer = null;
        let detailRefreshTimer = null;
        let currentNode = null;
        let currentTimeRange = 3600; // Default: 1 hour in seconds

        // === DATA FETCHING ===
        async function fetchNodes() {
            const res = await fetch(`${API_BASE}/nodes`);
            return res.ok ? await res.json() : [];
        }

        async function fetchSnapshot(nodeId) {
            const res = await fetch(`${API_BASE}/snapshots/latest?node_id=${nodeId}`);
            return res.ok ? await res.json() : null;
        }

        async function fetchTimeseries(nodeId, metric, duration = currentTimeRange) {
            const res = await fetch(`${API_BASE}/timeseries/${metric}?node_id=${nodeId}&duration=${duration}`);
            const data = res.ok ? await res.json() : [];
            console.log(`[fetchTimeseries] ${metric} for node ${nodeId} (${duration}s): ${data.length} points`);
            if (data.length > 0) {
                console.log('  First point:', data[0]);
                console.log('  Last point:', data[data.length - 1]);
                console.log('  Time range:', new Date(data[0].timestamp).toLocaleTimeString(), 'â†’', new Date(data[data.length - 1].timestamp).toLocaleTimeString());
            }
            return data;
        }

        // === UTILITIES ===
        function showMessage(msg, type = 'error') {
            const container = document.getElementById('message-container');
            container.innerHTML = `<div class="message ${type}">${msg}</div>`;
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function formatTime(timestamp) {
            const diff = Math.floor((Date.now() - new Date(timestamp)) / 1000);
            if (diff < 60) return `${diff}s ago`;
            if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
            return new Date(timestamp).toLocaleTimeString();
        }

        function calcUtilization(snapshot) {
            if (!snapshot) return { util: 0, utilized: 0, allocated: 0 };
            return {
                util: snapshot.kv_cache_utilization || 0,
                utilized: snapshot.utilized_blocks || 0,
                allocated: snapshot.allocated_blocks || 0
            };
        }

        // === CHART CREATION ===
        function createOrUpdateChart(canvasId, data, color = '#667eea') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            console.log(`[createOrUpdateChart] ${canvasId}: rendering ${data.length} points`);

            const now = new Date();
            const oneHourAgo = new Date(now - 3600 * 1000);

            if (charts[canvasId]) {
                charts[canvasId].data.labels = data.map(d => new Date(d.timestamp));
                charts[canvasId].data.datasets[0].data = data.map(d => d.value);
                // Update time axis to show current hour window
                charts[canvasId].options.scales.x.min = oneHourAgo;
                charts[canvasId].options.scales.x.max = now;
                charts[canvasId].update('none');
                console.log(`[createOrUpdateChart] ${canvasId}: updated with ${data.length} points`);
                return;
            }

            console.log(`[createOrUpdateChart] ${canvasId}: creating new chart with ${data.length} points`);

            charts[canvasId] = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: data.map(d => new Date(d.timestamp)),
                    datasets: [{
                        data: data.map(d => d.value),
                        borderColor: color,
                        backgroundColor: color + '33',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: ctx => `${ctx.parsed.y.toFixed(1)}%`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: oneHourAgo,
                            max: now,
                            time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                            grid: { color: 'rgba(0,0,0,0.05)' },
                            ticks: { color: '#666', font: { size: 11 } }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: 'rgba(0,0,0,0.05)' },
                            ticks: {
                                color: '#666',
                                font: { size: 11 },
                                callback: v => v + '%'
                            }
                        }
                    }
                }
            });
        }

        // === NODE CARD RENDERING ===
        function createNodeCardHTML(node) {
            return `
                <div class="node-card" onclick="openDetail(${node.id}, '${node.name}')" data-node-id="${node.id}">
                    <div class="node-header">
                        <div class="node-name">
                            <span data-name>${node.name}</span>
                            <span data-badge class="tracking-badge not-tracking">Loading...</span>
                        </div>
                        <div class="node-status" data-status>
                            ðŸ”´ Offline â€¢ ${node.host}:${node.port}
                        </div>
                    </div>
                    <div class="node-content">
                        <div class="node-stats">
                            <div class="utilization-display">
                                <div class="utilization-value" data-util>0.0%</div>
                                <div class="utilization-label">KV-Cache Utilization</div>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" data-progress style="width: 0%"></div>
                            </div>
                            <div class="ratio-display">
                                <div class="ratio-item">
                                    <div class="ratio-value" data-utilized>0</div>
                                    <div class="ratio-label">Utilized Blocks</div>
                                </div>
                                <div class="ratio-item">
                                    <div class="ratio-value" data-active>0</div>
                                    <div class="ratio-label">Allocated Blocks</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateNodeCard(card, node, snapshot) {
            const { util, utilized, allocated } = calcUtilization(snapshot);

            // Update tracking badge
            const badge = card.querySelector('[data-badge]');
            if (node.enabled) {
                if (snapshot) {
                    badge.textContent = 'Tracking';
                    badge.className = 'tracking-badge tracking';
                } else {
                    badge.textContent = 'Waiting...';
                    badge.className = 'tracking-badge not-tracking';
                }
            } else {
                badge.textContent = 'Disabled';
                badge.className = 'tracking-badge not-tracking';
            }

            // Update status
            const status = card.querySelector('[data-status]');
            const isOnline = snapshot && node.enabled;
            status.innerHTML = `
                ${isOnline ? 'ðŸŸ¢ Online' : 'ðŸ”´ Offline'} â€¢ ${node.host}:${node.port}
                ${snapshot ? ` â€¢ ${formatTime(snapshot.timestamp)}` : ''}
            `;

            // Update metrics
            card.querySelector('[data-util]').textContent = `${util.toFixed(1)}%`;
            card.querySelector('[data-progress]').style.width = `${util}%`;
            card.querySelector('[data-utilized]').textContent = utilized;
            card.querySelector('[data-active]').textContent = allocated;
        }

        // === UPDATE FUNCTIONS ===
        async function updateDashboard() {
            nodes = await fetchNodes();
            const container = document.getElementById('nodes-container');

            if (nodes.length === 0) {
                container.innerHTML = '<div class="no-data">No nodes configured. Click + to add a node.</div>';
                return;
            }

            const existingNodeIds = new Set(
                Array.from(container.querySelectorAll('[data-node-id]')).map(el => parseInt(el.dataset.nodeId))
            );
            const currentNodeIds = new Set(nodes.map(n => n.id));

            // Check if we need to rebuild (nodes added/removed)
            const needsRebuild = existingNodeIds.size !== currentNodeIds.size ||
                                 ![...currentNodeIds].every(id => existingNodeIds.has(id));

            if (needsRebuild) {
                // Complete rebuild
                container.innerHTML = nodes.map(n => createNodeCardHTML(n)).join('');

                // Update all cards
                for (const node of nodes) {
                    const card = container.querySelector(`[data-node-id="${node.id}"]`);
                    const snapshot = await fetchSnapshot(node.id);
                    updateNodeCard(card, node, snapshot);
                }
            } else {
                // Just update existing cards
                for (const node of nodes) {
                    const card = container.querySelector(`[data-node-id="${node.id}"]`);
                    if (!card) continue;

                    const snapshot = await fetchSnapshot(node.id);
                    updateNodeCard(card, node, snapshot);
                }
            }
        }

        // === NODE DETAIL ===
        async function openDetail(nodeId, nodeName) {
            console.log(`[openDetail] Opening detail for node ${nodeId} (${nodeName})`);

            const res = await fetch(`${API_BASE}/nodes/${nodeId}`);
            if (!res.ok) return showMessage('Failed to load node details');

            currentNode = await res.json();
            document.getElementById('detailNodeName').textContent = `${nodeName} - Details`;
            document.getElementById('detailModal').classList.add('active');

            const metrics = [
                { key: 'kv_cache_utilization', title: 'KV-Cache Utilization (%)', color: '#667eea' },
                { key: 'vllm_memory_utilization', title: 'vLLM Memory Utilization (%)', color: '#764ba2' },
                { key: 'allocated_blocks', title: 'Allocated Blocks (Total)', color: '#51cf66' },
                { key: 'utilized_blocks', title: 'Utilized Blocks (In Use)', color: '#228be6' },
                { key: 'memory_fragmentation', title: 'Memory Fragmentation', color: '#ff6b6b' },
                { key: 'used_bytes', title: 'Used Memory (Bytes)', color: '#ffd43b' },
                { key: 'num_processes', title: 'Number of Processes', color: '#339af0' }
            ];

            const controls = `
                <div style="position: relative;">
                    <div class="auto-refresh-indicator">
                        <div class="refresh-dot"></div>
                        <span>Auto-refresh: 2s</span>
                    </div>
                    <div class="node-controls">
                        <div class="node-controls-left">
                            <span class="node-status-badge ${currentNode.enabled ? 'enabled' : 'disabled'}">
                                ${currentNode.enabled ? 'Enabled' : 'Disabled'}
                            </span>
                            <span style="color: #666;">${currentNode.host}:${currentNode.port}</span>
                        </div>
                        <div class="node-controls-right">
                            <button class="btn-small btn-toggle ${!currentNode.enabled ? 'disabled' : ''}" onclick="toggleNode()">
                                ${currentNode.enabled ? 'Disable' : 'Enable'} Tracking
                            </button>
                            <button class="btn-small btn-edit" onclick="editNode()">Edit</button>
                            <button class="btn-small btn-delete" onclick="deleteNode()">Delete</button>
                        </div>
                    </div>
                    <div class="time-range-selector">
                        <span style="color: #666; margin-right: 10px; font-weight: 500;">Time Range:</span>
                        <button class="time-range-btn ${currentTimeRange === 3600 ? 'active' : ''}" onclick="changeTimeRange(3600)">1h</button>
                        <button class="time-range-btn ${currentTimeRange === 10800 ? 'active' : ''}" onclick="changeTimeRange(10800)">3h</button>
                        <button class="time-range-btn ${currentTimeRange === 21600 ? 'active' : ''}" onclick="changeTimeRange(21600)">6h</button>
                        <button class="time-range-btn ${currentTimeRange === 43200 ? 'active' : ''}" onclick="changeTimeRange(43200)">12h</button>
                        <button class="time-range-btn ${currentTimeRange === 86400 ? 'active' : ''}" onclick="changeTimeRange(86400)">24h</button>
                        <button class="time-range-btn ${currentTimeRange === 604800 ? 'active' : ''}" onclick="changeTimeRange(604800)">7d</button>
                    </div>
                </div>
            `;

            const chartsHtml = metrics.map(m => `
                <div class="chart-box">
                    <h3>${m.title}</h3>
                    <div class="chart-container">
                        <canvas id="detail-${m.key}"></canvas>
                    </div>
                </div>
            `).join('');

            document.getElementById('detailContent').innerHTML = controls + '<div class="charts-grid">' + chartsHtml + '</div>';

            console.log(`[openDetail] Fetching timeseries for ${metrics.length} metrics...`);

            for (const m of metrics) {
                const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                console.log(`[openDetail] Got ${data.length} points for ${m.key}, creating chart...`);
                createDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
            }

            console.log(`[openDetail] All charts created`);

            // Start auto-refresh for detail charts
            startDetailRefresh(nodeId, metrics);
        }

        function startDetailRefresh(nodeId, metrics) {
            // Clear any existing timer
            if (detailRefreshTimer) {
                clearInterval(detailRefreshTimer);
            }

            // Refresh charts every 2 seconds
            detailRefreshTimer = setInterval(async () => {
                console.log(`[detailRefresh] Updating charts for node ${nodeId}`);
                for (const m of metrics) {
                    const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                    updateDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
                }
            }, REFRESH_INTERVAL);
        }

        async function changeTimeRange(duration) {
            if (!currentNode) return;

            currentTimeRange = duration;
            console.log(`[changeTimeRange] Changed to ${duration}s (${duration/3600}h)`);

            // Re-fetch data and update all charts
            const nodeId = currentNode.id;
            const metrics = [
                { key: 'kv_cache_utilization', title: 'KV-Cache Utilization (%)', color: '#667eea' },
                { key: 'vllm_memory_utilization', title: 'vLLM Memory Utilization (%)', color: '#764ba2' },
                { key: 'allocated_blocks', title: 'Allocated Blocks (Total)', color: '#51cf66' },
                { key: 'utilized_blocks', title: 'Utilized Blocks (In Use)', color: '#228be6' },
                { key: 'memory_fragmentation', title: 'Memory Fragmentation', color: '#ff6b6b' },
                { key: 'used_bytes', title: 'Used Memory (Bytes)', color: '#ffd43b' },
                { key: 'num_processes', title: 'Number of Processes', color: '#339af0' }
            ];

            // Update button states
            document.querySelectorAll('.time-range-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Reload all charts with new time range
            for (const m of metrics) {
                const data = await fetchTimeseries(nodeId, m.key, currentTimeRange);
                createDetailChart(`detail-${m.key}`, data, m.color, currentTimeRange);
            }

            // Restart auto-refresh with new time range
            startDetailRefresh(nodeId, metrics);
        }

        function createDetailChart(canvasId, data, color, duration = currentTimeRange) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.warn(`[createDetailChart] Canvas not found: ${canvasId}`);
                return;
            }

            if (detailCharts[canvasId]) {
                detailCharts[canvasId].destroy();
            }

            console.log(`[createDetailChart] ${canvasId}: Creating chart with ${data.length} points for ${duration}s range`);

            const now = new Date();
            const startTime = new Date(now - duration * 1000);

            // Determine appropriate time unit based on duration
            let timeUnit = 'minute';
            let displayFormat = 'HH:mm';

            if (duration > 86400) { // > 1 day
                timeUnit = 'day';
                displayFormat = 'MMM dd';
            } else if (duration > 7200) { // > 2 hours
                timeUnit = 'hour';
                displayFormat = 'HH:mm';
            }

            const chartData = {
                labels: data.map(d => new Date(d.timestamp)),
                datasets: [{
                    data: data.map(d => d.value),
                    borderColor: color,
                    backgroundColor: color + '33',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: data.length > 100 ? 0 : 2  // Hide points if too many
                }]
            };

            console.log(`[createDetailChart] ${canvasId}: Chart has ${chartData.labels.length} labels and ${chartData.datasets[0].data.length} data points`);

            detailCharts[canvasId] = new Chart(canvas, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            min: startTime,
                            max: now,
                            time: {
                                unit: timeUnit,
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm',
                                    day: 'MMM dd'
                                }
                            }
                        },
                        y: { beginAtZero: true }
                    }
                }
            });
        }

        function updateDetailChart(canvasId, data, color, duration = currentTimeRange) {
            const chart = detailCharts[canvasId];
            if (!chart) {
                console.warn(`[updateDetailChart] Chart not found: ${canvasId}, creating new one`);
                createDetailChart(canvasId, data, color, duration);
                return;
            }

            const now = new Date();
            const startTime = new Date(now - duration * 1000);

            // Update data
            chart.data.labels = data.map(d => new Date(d.timestamp));
            chart.data.datasets[0].data = data.map(d => d.value);
            chart.data.datasets[0].pointRadius = data.length > 100 ? 0 : 2;

            // Update time axis
            chart.options.scales.x.min = startTime;
            chart.options.scales.x.max = now;

            // Update chart without animation for smoother updates
            chart.update('none');

            // Brief visual feedback on update
            const canvas = chart.canvas;
            if (canvas && canvas.parentElement) {
                canvas.parentElement.style.opacity = '0.7';
                setTimeout(() => {
                    canvas.parentElement.style.opacity = '1';
                }, 100);
            }
        }

        function closeDetailModal() {
            document.getElementById('detailModal').classList.remove('active');

            // Stop auto-refresh
            if (detailRefreshTimer) {
                clearInterval(detailRefreshTimer);
                detailRefreshTimer = null;
            }

            Object.values(detailCharts).forEach(c => c.destroy());
            detailCharts = {};
            currentNode = null;
            currentTimeRange = 3600; // Reset to default 1 hour
        }

        // === NODE ACTIONS ===
        async function toggleNode() {
            if (!currentNode) return;
            const newState = !currentNode.enabled;
            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}?enabled=${newState}`, { method: 'PUT' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage(`Node ${newState ? 'enabled' : 'disabled'} successfully`, 'success');
            } else {
                showMessage('Failed to toggle node');
            }
        }

        async function editNode() {
            if (!currentNode) return;
            const name = prompt('Node Name:', currentNode.name);
            if (!name) return;
            const host = prompt('Host:', currentNode.host);
            if (!host) return;
            const port = prompt('Port:', currentNode.port);
            if (!port) return;

            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}?name=${encodeURIComponent(name)}&host=${encodeURIComponent(host)}&port=${port}`, { method: 'PUT' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage('Node updated successfully', 'success');
            } else {
                showMessage('Failed to update node');
            }
        }

        async function deleteNode() {
            if (!currentNode) return;
            if (!confirm(`Delete "${currentNode.name}"?\n\nThis will delete all data and cannot be undone.`)) return;

            const res = await fetch(`${API_BASE}/nodes/${currentNode.id}`, { method: 'DELETE' });
            if (res.ok) {
                closeDetailModal();
                updateDashboard();
                showMessage('Node deleted successfully', 'success');
            } else {
                showMessage('Failed to delete node');
            }
        }

        // === ADD NODE ===
        function openAddModal() {
            document.getElementById('addNodeModal').classList.add('active');
            document.getElementById('nodeName').value = '';
            document.getElementById('nodeHost').value = '';
            document.getElementById('nodePort').value = '6767';
            document.getElementById('add-message').innerHTML = '';
        }

        function closeAddModal() {
            document.getElementById('addNodeModal').classList.remove('active');
        }

        async function handleAddNode(e) {
            e.preventDefault();
            const name = document.getElementById('nodeName').value.trim();
            const host = document.getElementById('nodeHost').value.trim();
            const port = parseInt(document.getElementById('nodePort').value);

            const res = await fetch(`${API_BASE}/nodes`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, host, port })
            });

            if (res.ok) {
                document.getElementById('add-message').innerHTML = `<div class="message success">Node "${name}" added!</div>`;
                setTimeout(() => {
                    closeAddModal();
                    updateDashboard();
                }, 1500);
            } else {
                const err = await res.json();
                document.getElementById('add-message').innerHTML = `<div class="message error">${err.detail || 'Failed to add node'}</div>`;
            }
        }

        // === INIT ===
        updateDashboard();
        refreshTimer = setInterval(updateDashboard, REFRESH_INTERVAL);

        document.getElementById('addNodeModal').addEventListener('click', e => {
            if (e.target.id === 'addNodeModal') closeAddModal();
        });
        document.getElementById('detailModal').addEventListener('click', e => {
            if (e.target.id === 'detailModal') closeDetailModal();
        });
    </script>
</body>
</html>
